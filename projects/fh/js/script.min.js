jQuery(document).ready(function($){
	var transitionEnd = 'webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend';
	var transitionsSupported = ( $('.csstransitions').length > 0 );
	//if browser does not support transitions - use a different event to trigger them
	if( !transitionsSupported ) transitionEnd = 'noTransition';

	//should add a loding while the events are organized

	function SchedulePlan( element ) {
		this.element = element;
		this.timeline = this.element.find('.timeline');
		this.timelineItems = this.timeline.find('li');
		this.timelineItemsNumber = this.timelineItems.length;
		this.timelineStart = getScheduleTimestamp(this.timelineItems.eq(0).text());
		//need to store delta (in our case half hour) timestamp
		this.timelineUnitDuration = getScheduleTimestamp(this.timelineItems.eq(1).text()) - getScheduleTimestamp(this.timelineItems.eq(0).text());

		this.eventsWrapper = this.element.find('.events');
		this.eventsGroup = this.eventsWrapper.find('.events-group');
		this.singleEvents = this.eventsGroup.find('.single-event');
		this.eventSlotHeight = this.eventsGroup.eq(0).children('.top-info').outerHeight();

		this.modal = this.element.find('.event-modal');
		this.modalHeader = this.modal.find('.header');
		this.modalHeaderBg = this.modal.find('.header-bg');
		this.modalBody = this.modal.find('.body');
		this.modalBodyBg = this.modal.find('.body-bg');
		this.modalMaxWidth = 800;
		this.modalMaxHeight = 480;

		this.animating = false;

		this.initSchedule();
	}

	SchedulePlan.prototype.initSchedule = function() {
		this.scheduleReset();
		this.initEvents();
	};

	SchedulePlan.prototype.scheduleReset = function() {
		var mq = this.mq();
		if( mq == 'desktop' && !this.element.hasClass('js-full') ) {
			//in this case you are on a desktop version (first load or resize from mobile)
			this.eventSlotHeight = this.eventsGroup.eq(0).children('.top-info').outerHeight();
			this.element.addClass('js-full');
			this.placeEvents();
			this.element.hasClass('modal-is-open') && this.checkEventModal();
		} else if(  mq == 'mobile' && this.element.hasClass('js-full') ) {
			//in this case you are on a mobile version (first load or resize from desktop)
			this.element.removeClass('js-full loading');
			this.eventsGroup.children('ul').add(this.singleEvents).removeAttr('style');
			this.eventsWrapper.children('.grid-line').remove();
			this.element.hasClass('modal-is-open') && this.checkEventModal();
		} else if( mq == 'desktop' && this.element.hasClass('modal-is-open')){
			//on a mobile version with modal open - need to resize/move modal window
			this.checkEventModal('desktop');
			this.element.removeClass('loading');
		} else {
			this.element.removeClass('loading');
		}
	};

	SchedulePlan.prototype.initEvents = function() {
		var self = this;

		this.singleEvents.each(function(){
			//create the .event-date element for each event
			var durationLabel = '<span class="event-date">'+$(this).data('start')+' - '+$(this).data('end')+'</span>';
			$(this).children('a').prepend($(durationLabel));

			//detect click on the event and open the modal
			$(this).on('click', 'a', function(event){
				event.preventDefault();
				if( !self.animating ) self.openModal($(this));
			});
		});

		//close modal window
		this.modal.on('click', '.close', function(event){
			event.preventDefault();
			if( !self.animating ) self.closeModal(self.eventsGroup.find('.selected-event'));
		});
		this.element.on('click', '.cover-layer', function(event){
			if( !self.animating && self.element.hasClass('modal-is-open') ) self.closeModal(self.eventsGroup.find('.selected-event'));
		});
	};

	SchedulePlan.prototype.placeEvents = function() {
		var self = this;
		this.singleEvents.each(function(){
			//place each event in the grid -> need to set top position and height
			var start = getScheduleTimestamp($(this).attr('data-start')),
				duration = getScheduleTimestamp($(this).attr('data-end')) - start;

			var eventTop = self.eventSlotHeight*(start - self.timelineStart)/self.timelineUnitDuration,
				eventHeight = self.eventSlotHeight*duration/self.timelineUnitDuration;

			$(this).css({
				top: (eventTop -1) +'px',
				height: (eventHeight+1)+'px'
			});
		});

		this.element.removeClass('loading');
	};

	SchedulePlan.prototype.openModal = function(event) {
		var self = this;
		var mq = self.mq();
		this.animating = true;

		//update event name and time
		this.modalHeader.find('.event-name').text(event.find('.event-name').text());
		this.modalHeader.find('.event-date').text(event.find('.event-date').text());
		this.modal.attr('data-event', event.parent().attr('data-event'));

		//update event content
		this.modalBody.find('.event-info').load(event.parent().attr('data-content')+'.html .event-info > *', function(data){
			//once the event content has been loaded
			self.element.addClass('content-loaded');
		});

		this.element.addClass('modal-is-open');

		setTimeout(function(){
			//fixes a flash when an event is selected - desktop version only
			event.parent('li').addClass('selected-event');
		}, 10);

		if( mq == 'mobile' ) {
			self.modal.one(transitionEnd, function(){
				self.modal.off(transitionEnd);
				self.animating = false;
			});
		} else {
			var eventTop = event.offset().top - $(window).scrollTop(),
				eventLeft = event.offset().left,
				eventHeight = event.innerHeight(),
				eventWidth = event.innerWidth();

			var windowWidth = $(window).width(),
				windowHeight = $(window).height();

			var modalWidth = ( windowWidth*.8 > self.modalMaxWidth ) ? self.modalMaxWidth : windowWidth*.8,
				modalHeight = ( windowHeight*.8 > self.modalMaxHeight ) ? self.modalMaxHeight : windowHeight*.8;

			var modalTranslateX = parseInt((windowWidth - modalWidth)/2 - eventLeft),
				modalTranslateY = parseInt((windowHeight - modalHeight)/2 - eventTop);

			var HeaderBgScaleY = modalHeight/eventHeight,
				BodyBgScaleX = (modalWidth - eventWidth);

			//change modal height/width and translate it
			self.modal.css({
				top: eventTop+'px',
				left: eventLeft+'px',
				height: modalHeight+'px',
				width: modalWidth+'px',
			});
			transformElement(self.modal, 'translateY('+modalTranslateY+'px) translateX('+modalTranslateX+'px)');

			//set modalHeader width
			self.modalHeader.css({
				width: eventWidth+'px',
			});
			//set modalBody left margin
			self.modalBody.css({
				marginLeft: eventWidth+'px',
			});

			//change modalBodyBg height/width ans scale it
			self.modalBodyBg.css({
				height: eventHeight+'px',
				width: '1px',
			});
			transformElement(self.modalBodyBg, 'scaleY('+HeaderBgScaleY+') scaleX('+BodyBgScaleX+')');

			//change modal modalHeaderBg height/width and scale it
			self.modalHeaderBg.css({
				height: eventHeight+'px',
				width: eventWidth+'px',
			});
			transformElement(self.modalHeaderBg, 'scaleY('+HeaderBgScaleY+')');

			self.modalHeaderBg.one(transitionEnd, function(){
				//wait for the  end of the modalHeaderBg transformation and show the modal content
				self.modalHeaderBg.off(transitionEnd);
				self.animating = false;
				self.element.addClass('animation-completed');
			});
		}

		//if browser do not support transitions -> no need to wait for the end of it
		if( !transitionsSupported ) self.modal.add(self.modalHeaderBg).trigger(transitionEnd);
	};

	SchedulePlan.prototype.closeModal = function(event) {
		var self = this;
		var mq = self.mq();

		this.animating = true;

		if( mq == 'mobile' ) {
			this.element.removeClass('modal-is-open');
			this.modal.one(transitionEnd, function(){
				self.modal.off(transitionEnd);
				self.animating = false;
				self.element.removeClass('content-loaded');
				event.removeClass('selected-event');
			});
		} else {
			var eventTop = event.offset().top - $(window).scrollTop(),
				eventLeft = event.offset().left,
				eventHeight = event.innerHeight(),
				eventWidth = event.innerWidth();

			var modalTop = Number(self.modal.css('top').replace('px', '')),
				modalLeft = Number(self.modal.css('left').replace('px', ''));

			var modalTranslateX = eventLeft - modalLeft,
				modalTranslateY = eventTop - modalTop;

			self.element.removeClass('animation-completed modal-is-open');

			//change modal width/height and translate it
			this.modal.css({
				width: eventWidth+'px',
				height: eventHeight+'px'
			});
			transformElement(self.modal, 'translateX('+modalTranslateX+'px) translateY('+modalTranslateY+'px)');

			//scale down modalBodyBg element
			transformElement(self.modalBodyBg, 'scaleX(0) scaleY(1)');
			//scale down modalHeaderBg element
			transformElement(self.modalHeaderBg, 'scaleY(1)');

			this.modalHeaderBg.one(transitionEnd, function(){
				//wait for the  end of the modalHeaderBg transformation and reset modal style
				self.modalHeaderBg.off(transitionEnd);
				self.modal.addClass('no-transition');
				setTimeout(function(){
					self.modal.add(self.modalHeader).add(self.modalBody).add(self.modalHeaderBg).add(self.modalBodyBg).attr('style', '');
				}, 10);
				setTimeout(function(){
					self.modal.removeClass('no-transition');
				}, 20);

				self.animating = false;
				self.element.removeClass('content-loaded');
				event.removeClass('selected-event');
			});
		}

		//browser do not support transitions -> no need to wait for the end of it
		if( !transitionsSupported ) self.modal.add(self.modalHeaderBg).trigger(transitionEnd);
	}

	SchedulePlan.prototype.mq = function(){
		//get MQ value ('desktop' or 'mobile')
		var self = this;
		return window.getComputedStyle(this.element.get(0), '::before').getPropertyValue('content').replace(/["']/g, '');
	};

	SchedulePlan.prototype.checkEventModal = function(device) {
		this.animating = true;
		var self = this;
		var mq = this.mq();

		if( mq == 'mobile' ) {
			//reset modal style on mobile
			self.modal.add(self.modalHeader).add(self.modalHeaderBg).add(self.modalBody).add(self.modalBodyBg).attr('style', '');
			self.modal.removeClass('no-transition');
			self.animating = false;
		} else if( mq == 'desktop' && self.element.hasClass('modal-is-open') ) {
			self.modal.addClass('no-transition');
			self.element.addClass('animation-completed');
			var event = self.eventsGroup.find('.selected-event');

			var eventTop = event.offset().top - $(window).scrollTop(),
				eventLeft = event.offset().left,
				eventHeight = event.innerHeight(),
				eventWidth = event.innerWidth();

			var windowWidth = $(window).width(),
				windowHeight = $(window).height();

			var modalWidth = ( windowWidth*.8 > self.modalMaxWidth ) ? self.modalMaxWidth : windowWidth*.8,
				modalHeight = ( windowHeight*.8 > self.modalMaxHeight ) ? self.modalMaxHeight : windowHeight*.8;

			var HeaderBgScaleY = modalHeight/eventHeight,
				BodyBgScaleX = (modalWidth - eventWidth);

			setTimeout(function(){
				self.modal.css({
					width: modalWidth+'px',
					height: modalHeight+'px',
					top: (windowHeight/2 - modalHeight/2)+'px',
					left: (windowWidth/2 - modalWidth/2)+'px',
				});
				transformElement(self.modal, 'translateY(0) translateX(0)');
				//change modal modalBodyBg height/width
				self.modalBodyBg.css({
					height: modalHeight+'px',
					width: '1px',
				});
				transformElement(self.modalBodyBg, 'scaleX('+BodyBgScaleX+')');
				//set modalHeader width
				self.modalHeader.css({
					width: eventWidth+'px',
				});
				//set modalBody left margin
				self.modalBody.css({
					marginLeft: eventWidth+'px',
				});
				//change modal modalHeaderBg height/width and scale it
				self.modalHeaderBg.css({
					height: eventHeight+'px',
					width: eventWidth+'px',
				});
				transformElement(self.modalHeaderBg, 'scaleY('+HeaderBgScaleY+')');
			}, 10);

			setTimeout(function(){
				self.modal.removeClass('no-transition');
				self.animating = false;
			}, 20);
		}
	};

	var schedules = $('.cd-schedule');
	var objSchedulesPlan = [],
		windowResize = false;

	if( schedules.length > 0 ) {
		schedules.each(function(){
			//create SchedulePlan objects
			objSchedulesPlan.push(new SchedulePlan($(this)));
		});
	}

	$(window).on('resize', function(){
		if( !windowResize ) {
			windowResize = true;
			(!window.requestAnimationFrame) ? setTimeout(checkResize) : window.requestAnimationFrame(checkResize);
		}
	});

	$(window).keyup(function(event) {
		if (event.keyCode == 27) {
			objSchedulesPlan.forEach(function(element){
				element.closeModal(element.eventsGroup.find('.selected-event'));
			});
		}
	});

	function checkResize(){
		objSchedulesPlan.forEach(function(element){
			element.scheduleReset();
		});
		windowResize = false;
	}

	function getScheduleTimestamp(time) {
		//accepts hh:mm format - convert hh:mm to timestamp
		time = time.replace(/ /g,'');
		var timeArray = time.split(':');
		var timeStamp = parseInt(timeArray[0])*60 + parseInt(timeArray[1]);
		return timeStamp;
	}

	function transformElement(element, value) {
		element.css({
		    '-moz-transform': value,
		    '-webkit-transform': value,
			'-ms-transform': value,
			'-o-transform': value,
			'transform': value
		});
	}
});


(function () {
   // header scroll
   const body = document.body;
  //  const triggerMenu = document.querySelector(".page-header__btn-burger");

   const scrollUp = "scroll-up";
   const scrollDown = "scroll-down";
   let lastScroll = 0;

  //  triggerMenu.addEventListener("click", () => {
  //    body.classList.toggle("menu-open");
  //    triggerMenu.classList.toggle("active");
  //  });

   window.addEventListener("scroll", () => {
     const currentScroll = window.pageYOffset;
     if (currentScroll <= 0) {
       body.classList.remove(scrollUp);
       return;
     }

     if (currentScroll > lastScroll && !body.classList.contains(scrollDown)) {
       // down
       body.classList.remove(scrollUp);
       body.classList.add(scrollDown);
     } else if (currentScroll < lastScroll && body.classList.contains(scrollDown)) {
       // up
       body.classList.remove(scrollDown);
       body.classList.add(scrollUp);
     }
     lastScroll = currentScroll;
   });
})()

// mob menu

export let mobileMenuToggle = () => {
  const page = document.querySelector('.page');
  const btnMenuOpen = document.querySelector('.page-header__btn-menu');
  const btnMenuOpenClose = document.querySelector('.mobile-menu__btn-close');
  const headerTop = document.querySelector('.page-header');
  const mobMenu = document.querySelector('.mobile-menu');

  if (btnMenuOpen) {
    btnMenuOpen.addEventListener('click', function() {
      headerTop.classList.add('page-header--mob');
      page.classList.add('page--overlay');
      mobMenu.classList.add('active');
    });
  }

  if (btnMenuOpenClose) {
    btnMenuOpenClose.addEventListener('click', function() {
      headerTop.classList.remove('page-header--mob');
      page.classList.remove('page--overlay');
      mobMenu.classList.remove('active');
    });
  }

  if (mobMenu) {
    mobMenu.addEventListener('click', () => {
      mobMenu.classList.remove('active');
    });
  }

  window.onresize = function() {
    if (window.screen.width > 768) {
      document.querySelector('.page').classList.remove('page--overlay');
      if (headerTop.classList.contains('page-header--mob')) {
        headerTop.classList.remove('page-header--mob');
      }
    }
  };
};



mobileMenuToggle();



(function() {
  const cities = [
    'Санкт-Петербург',
    'Нижний Новгород',
    'Казань',
    'Тольятти',
    'Самара',
    'Ульяновск',
    'Архангельск',
    'Ижевск',
    'Ярославль',
    'Петрозаводск',
    'Мурманск',
    'Рязань',
    'Набережные Челны',
    'Тула',
    'Нижнекамск',
  ];

  let listCity = cities.filter(item => item !== 'Санкт-Петербург');
  let sortCities = listCity.sort();
  sortCities.unshift('Санкт-Петербург');

  let items = [...document.querySelectorAll('.city-list li button')];
  let navItems = [...document.querySelectorAll('.nav-city__list li a')];

  for (let j = 0; j < sortCities.length; j++) {
    for (let i = 0; i < items.length; i++) {
      if (i == j) {
        items[i].innerText = sortCities[j];
      }
    }
    for (let i = 0; i < navItems.length; i++) {
      if (i == j) {
        navItems[i].innerText = sortCities[j];
      }
    }
  }

   let navCityToggle = () => {
    const city = document.querySelector('.nav-city__title');
    const cityName = document.querySelector('.nav-city__title span');
    const cityList = document.querySelector('.nav-city__wrapper');
    const cityListOpen = document.querySelector('.nav-city__wrapper.d-block');

    const toggleMenuCity = () => {
      cityList.classList.toggle('d-block');
      cityList.classList.toggle('d-none');
    };

    if (city) {
      city.addEventListener('click', evt => {
        evt.stopPropagation();
        toggleMenuCity();
      });
    }

    document.addEventListener('click', evt => {
      let target = evt.target;
      let its_menu = target == cityList || cityList.contains(target);
      let its_hamburger = target == city;
      let menu_is_active = cityList.classList.contains('d-block');

      if (!its_menu && !its_hamburger && menu_is_active) {
        toggleMenuCity();
      }
    });

    if (cityList) {
      cityList.addEventListener('click', evt => {
        evt.preventDefault();
        let target = evt.target.tagName;
        if (target == 'A') {
          let activeNameCity = evt.target.innerText;
          cityName.innerText = activeNameCity;
          toggleMenuCity();
        }
      });
    }

    if (cityListOpen) {
      console.log('open');
      page.addEventListener('click', () => {
        console.log(evt.target);
        toggleMenuCity();
      });
    }
  };

  document.addEventListener('DOMContentLoaded', navCityToggle);
})();

(function() {
  const location = () => {
    const city = document.querySelector('.nav-city__title');
    // создание блока
    let page = document.querySelector('.nav-menu');
    let box = document.createElement('div');
    let title = document.createElement('div');
    let btnYes = document.createElement('button');
    let btnNo = document.createElement('button');

    box.className = 'location';
    title.className = 'location__title';
    btnYes.className = 'button active';
    btnNo.className = 'button';
    title.innerText = 'Ваш город Санкт-Петербург?';
    btnYes.innerText = 'Да';
    btnNo.innerText = 'Нет';
    btnNo.setAttribute('data-bs-target', '#modalToggleCityChange');
    btnNo.setAttribute('data-bs-toggle', 'modal');
    btnNo.setAttribute('data-bs-dismiss', 'modal');
    box.append(title);
    box.appendChild(btnYes);
    box.appendChild(btnNo);

    setTimeout(() => {
      page.append(box);

      // выбор города
      const blockLocation = document.querySelector('.location');
      const activeCity = document.querySelector('.nav-city__title span');
      const listCity = document.querySelector('.city-list');

      if (blockLocation) {
        blockLocation.addEventListener('click', evt => {
          let target = evt.target;
          if (target.tagName == 'BUTTON' && target.innerText == 'Да') {
            activeCity.innerText = 'Санкт-Петербург';
            box.remove();
          } else {
            evt.target.previousElementSibling.classList.toggle('active')
            evt.target.classList.toggle('active');
            if (listCity) {
              listCity.addEventListener('click', evt => {
                let target = evt.target;
                target.classList.toggle('active');
                if (target.tagName == 'BUTTON') {
                  activeCity.innerText = target.innerText;
                  box.remove();
                }
              });
            }
          }
        });

        // если открыли список городов в меню
        if (city) {
          city.addEventListener('click', evt => {
            box.remove();
          });
        }
      }
    },);
  };

  document.addEventListener('DOMContentLoaded', location);
})();

// Example starter JavaScript for disabling form submissions if there are invalid fields
(function() {
  'use strict';

  // Fetch all the forms we want to apply custom Bootstrap validation styles to
  let forms = document.querySelectorAll('.needs-validation');
  let modalTour = document.querySelector('.modal-tour');
  let modalSubmitForm = document.getElementById('modal-submit-form');

  // document.addEventListener('DOMContentLoaded', () => {

  // });


  if (modalTour) {
    const modal = new bootstrap.Modal(modalTour);
    Array.prototype.slice.call(forms).forEach(function(form) {
      form.addEventListener(
        'submit',
        function(event) {
          if (!form.checkValidity()) {
            event.preventDefault();
            event.stopPropagation();
            form.classList.add('was-validated');
          } else {
            event.preventDefault();
            form.classList.remove('was-validated');
            const modalSubmit = new bootstrap.Modal(modalSubmitForm);

            modal.hide();
            modalSubmit.show();

            modalSubmitForm.addEventListener('hidden.bs.modal', function() {
              form.submit();
              form.reset();
            });
          }
        },
        false,
      );
    });
  } else {
    Array.prototype.slice.call(forms).forEach(function(form) {
      form.addEventListener(
        'submit',
        function(event) {
          if (!form.checkValidity()) {
            event.preventDefault();
            event.stopPropagation();
            form.classList.add('was-validated');
          } else {
            event.preventDefault();
            form.classList.remove('was-validated');
            const modalSubmit = new bootstrap.Modal(modalSubmitForm);
            modalSubmit.show();

            modalSubmitForm.addEventListener('hidden.bs.modal', function() {
              form.submit();
              form.reset();
            });
          }
        },
        false,
      );
    });
  }


  // маска для телефона
  // let phones = document.querySelectorAll('input[type="tel"]');
  // phones.forEach(phone => {
  //   let maskOptions = {
  //     mask: '{8} (000)000-00-00',
  //     lazy: true,
  //     autofix: true, // bound value
  //     placeholderChar: '9',
  //   };
  //   new IMask(phone, maskOptions);
  // });
})();


const mql = window.matchMedia('(min-width: 767px)');
const sliderStoriesProps = {
  spaceBetween: 10,
  navigation: {
    nextEl: '.swiper-button-next',
    prevEl: '.swiper-button-prev',
  },
  breakpoints: {
    320: {
      slidesPerView: 1.1,
      spaceBetween: 10,
    },
    567: {
      slidesPerView: 1.7,
      spaceBetween: 10,
    },
    700: {
      slidesPerView: 2.2,
      spaceBetween: 10,
    },
    850: {
      slidesPerView: 2.6,
      spaceBetween: 10,
    },
    960: {
      slidesPerView: 3,
    },
    1200: {
      slidesPerView: 3.3,
    },
  },
};
const sliderProfitProps = {
  spaceBetween: 10,
  navigation: {
    nextEl: '.swiper-button-next',
    prevEl: '.swiper-button-prev',
  },
  breakpoints: {
    320: {
      slidesPerView: 1.5,
      spaceBetween: 10,
    },
    567: {
      slidesPerView: 2.5,
      spaceBetween: 10,
    },
    700: {
      slidesPerView: 3.5,
      spaceBetween: 10,
    },
    960: {
      slidesPerView: 3,
    },
    1200: {
      slidesPerView: 3.6,
    },
  },
};

const breakpoint = window.matchMedia('(max-width:767px)');
const breakpointProfit = window.matchMedia('(min-width:991px)');

// keep track of swiper instances to destroy later
let mySwiper;
let mySwiperProfit;

const getEnableSwiper = (slider, id, props) => {
  slider = new Swiper(id, props);
};

const getBreakpointChecker = (point, slider, id, props) => {
  // if larger viewport and multi-row layout needed
  if (point.matches === true) {
    // clean up old instances and inline styles when available
    if (slider !== undefined) slider.destroy(true, true);
    // or/and do nothing
    return;

    // else if a small viewport and single column layout needed
  } else if (point.matches === false) {
    // fire small viewport version of swiper
    return getEnableSwiper(slider, id, props);
  }
};

// keep an eye on viewport size changes
breakpoint.addListener(
  getBreakpointChecker(
    breakpoint,
    mySwiper,
    '#slider-vacancies-stories',
    sliderStoriesProps,
  ),
);
breakpointProfit.addListener(
  getBreakpointChecker(
    breakpointProfit,
    mySwiperProfit,
    '#slider-profit',
    sliderProfitProps,
  ),
);

// kickstart
getBreakpointChecker(
  breakpoint,
  mySwiper,
  '#slider-vacancies-stories',
  sliderStoriesProps,
);
getBreakpointChecker(
  breakpointProfit,
  mySwiperProfit,
  '#slider-profit',
  sliderProfitProps,
);

const tooltipTriggerList = document.querySelectorAll(
  '[data-bs-toggle="tooltip"]',
);
const tooltipList = [...tooltipTriggerList].map(
  tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl),
);

